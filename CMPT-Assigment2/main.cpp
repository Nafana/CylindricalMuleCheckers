#include <iostream>
#include <iomanip>
#include <math.h>
#include <string>

using namespace std;

const int MAX_ARRAY_SIZE = 18;
const int MIN_ARRAY_SIZE = 8;
const int MAX_PIECES = 72;
const int NOPLAYER = 0;
const int WHITEWINS = 1;
const int REDWINS = 2;
const int NOONEWINS = 0;
const int WHITESOLDIER = 1;
const int WHITEMULE = 2;
const int WHITEKING = 3;
const int REDSOLDIER = 4;
const int REDMULE = 5;
const int REDKING = 6;
const int WHITEPLAYER = 1;
const int REDPLAYER = 2;
const int TABLESPACING = 4;

const string WHITESOLIDER_DISPLAY = "WS";
const string WHITEMULE_DISPLAY = "WM";
const string WHITEKING_DISPLAY = "WK";
const string REDSOLIDER_DISPLAY = "RS";
const string REDMULE_DISPLAY = "RM";
const string REDKING_DISPLAY = "RK";

void InitializeBoard(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard);

void DisplayBoard(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard);

int CountJumps(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard, int player, int xLocArray[], int yLocArray[]);

bool CheckList(int inArray1[], int inArray2[], int xIndex, int yIndex);

int CountMove1Squares(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard, int player, int xLocArray[], int yLocArray[]);

bool IsMove1Square(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard, int player, int xLoc, int yLoc);

bool IsJump(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard, int player, int xLoc, int yLoc);

bool MakeMove(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE],
	int numRowsInBoard, int player, int fromSquareNum,
	int toSquareNum, bool &jumped);

bool CheckWin(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard);

bool isEven(int value);
int checkerBelongsToPlayer(int checkerValue);
int getWrappedCoordinate(int locX, int numRowsInBoard);

int main() {

	int myCMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE] = { 0 };

	int xIndicesMove[MAX_PIECES] = { 0 };
	int xIndicesJump[MAX_PIECES] = { 0 };
	int yIndicesMove[MAX_PIECES] = { 0 };
	int yIndicesJump[MAX_PIECES] = { 0 };

	const int MAX_BOARDSIZE_TRIES = 3;

	int numRowsInBoard = 0;

	for (int i = 0; i < MAX_BOARDSIZE_TRIES; i++)
	{

		cout << "Enter the number of squares along each edge of board\n";
		
		if (!(cin >> numRowsInBoard)) {
			numRowsInBoard = 0;
			cin.clear();
			cin.ignore();
			cout << "ERROR:  Board size is not an integer\n";
		} else {
			if (numRowsInBoard < MIN_ARRAY_SIZE) {
				cout << "ERROR:  Board size too small\n";
			} else if (numRowsInBoard > MAX_ARRAY_SIZE) {
				cout << "ERROR:  Board size too large\n";
			} else {
				if (isEven(numRowsInBoard)) {
					break;
				}
				else {
					cout << "ERROR:  Board size odd\n";
				}
			}
		}

		cout << MIN_ARRAY_SIZE << " <= number of squares <= " << MAX_ARRAY_SIZE << endl;

		if (i == MAX_BOARDSIZE_TRIES - 1) {
			cout << "ERROR:  Too many errors entering the size of the board";

			return -1;
		}

	}

	InitializeBoard(myCMCheckersBoard, numRowsInBoard);
	DisplayBoard(myCMCheckersBoard, numRowsInBoard);
	
	return 0;
}

// IMPLEMENTED: MAX
// This method puts the checkers on the board, initializes it by checking some basic properties of the location.
void InitializeBoard(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard)
{

	int currentRow = 1;
	int noPeicesPositionInitial = (numRowsInBoard / 2);

	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j < numRowsInBoard; j++)
		{
			
			if (!isEven(currentRow) && isEven(j + (i * 10))) {
				CMCheckersBoard[i][j] = 0;
				continue;
			} else if (isEven(currentRow) && !isEven(j + (i * 10))) {
				CMCheckersBoard[i][j] = 0;
				continue;
			}

			// Since it's gotten to this point, clearly we need to place a checker, let's determine which one.
			//	Unless of course we're in no man's land.

			if (currentRow == 1) { // White mule
				CMCheckersBoard[i][j] = 2;
			}
			else if (currentRow == numRowsInBoard) { // Red Mule
				CMCheckersBoard[i][j] = 5;
			}
			else if (currentRow == noPeicesPositionInitial || currentRow == noPeicesPositionInitial + 1) {
				// Blank rows here.
				CMCheckersBoard[i][j] = 0;
			}
			else if (currentRow < noPeicesPositionInitial) {
				// Place white soldier
				CMCheckersBoard[i][j] = 1;
			}
			else {
				// place red soldier
				CMCheckersBoard[i][j] = 4;
			}


		}
		currentRow++;
	}

}

// IMPLEMENTED: MAX
// This method displays the board, generated by the InitializeBoard method.
void DisplayBoard(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard)
{
	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j <= numRowsInBoard; j++)
		{
			if (j == numRowsInBoard) {
				cout << endl;
				break;
			}

			switch (CMCheckersBoard[i][j])
			{
				case 0: {
					cout << setw(TABLESPACING) << j + (i * numRowsInBoard);
					continue;
				} case 1: {
					cout << setw(TABLESPACING) << WHITESOLIDER_DISPLAY;
					continue;
				} case 2: {
					cout << setw(TABLESPACING) << WHITEMULE_DISPLAY;
					continue;
				} case 3: {
					cout << setw(TABLESPACING) << WHITEKING_DISPLAY;
					continue;
				} case 4: {
					cout << setw(TABLESPACING) << REDSOLIDER_DISPLAY;
					continue;
				} case 5: {
					cout << setw(TABLESPACING) << REDMULE_DISPLAY;
					continue;
				} case 6: {
					cout << setw(TABLESPACING) << REDKING_DISPLAY;
					continue;
				} default:
					break;
			}

		}
	}
}

// IMPLEMENTED: Ryan
// This method collects coordinates for all checkers that can jump, belonging to the player.
// Returns amount of checkers that can jump.
int CountJumps(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard, int player, int xLocArray[], int yLocArray[])
{
	int JumpCounter = 0;
	for (int i = 0; i < numRowsInBoard; i++)
	{
		xLocArray[i] = -1;
		yLocArray[i] = -1;
	}
	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j < numRowsInBoard; j++)
		{
			if (checkerBelongsToPlayer(CMCheckersBoard[i][j])==player)
			{
				if (IsJump(CMCheckersBoard, numRowsInBoard, player, j, i))
				{
					xLocArray[JumpCounter] = j;
					yLocArray[JumpCounter] = i;
					JumpCounter++;
				}
			}
		}

	}
	return JumpCounter;
}

// TOBEIMPLEMENTED: Jason
bool CheckList(int inArray1[], int inArray2[], int xIndex, int yIndex)
{
	return false;
}
// IMPLEMENTED: Max
// This method returns the amount of checkers that can move one space without jumping, from a particular player.
//		NOTE: Although assigment requires we have xLocArray, and yLocArray, since those arrays are never passed
//            by reference, there isn't a point in putting anything in them, since they'll get erased.
//		NOT-TESTED: Needs IsMove1Square method to work.
int CountMove1Squares(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard, int player, int xLocArray[], int yLocArray[])
{ 
	int singleMoveCounter = 0;

	for (int i = 0; i < MAX_PIECES; i++)
	{
		xLocArray[i] = -1;
		yLocArray[i] = -1;
	}

	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j <= numRowsInBoard; j++)
		{
			// We've got our player's checker
			if (checkerBelongsToPlayer(CMCheckersBoard[i][j]) == player) {
				if (IsMove1Square(CMCheckersBoard, numRowsInBoard, player, j, i)) {
					xLocArray[singleMoveCounter] = j;
					yLocArray[singleMoveCounter] = i;		
					singleMoveCounter++;
				}
			}
		}

	}

	return singleMoveCounter;
}

// TOBEIMPLEMENTED: Jason
bool IsMove1Square(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard, int player, int xLoc, int yLoc)
{
	return false;
}

// IMPLEMENTED: Max
// This method checks to see if a particular peice can jump, takes into account impossible off-board moves.
//	NOTE: Note NOT tested due to other methods not being completed. Also there is a lot of repetion which should
//        Be moved into it's own method, do that later, will cut down on checks needed.
bool IsJump(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard, int player, int xLoc, int yLoc)
{
	if (checkerBelongsToPlayer(CMCheckersBoard[yLoc][xLoc])) {
		// The checker indeed belongs to the player.
		if (player == 1) { // WHITE PLAYER
			
			if (yLoc + 1 <= numRowsInBoard - 1) {
				// DIAG. RIGHT
				if (checkerBelongsToPlayer(CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc - 1, numRowsInBoard)]) == 0
					&& CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc - 2, numRowsInBoard)] == 0) {
					return true;
				} else if (checkerBelongsToPlayer(CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc + 1, numRowsInBoard)]) == 0
					&& CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc + 2, numRowsInBoard)] == 0) {
					return true;
				}

			}
			else {
				// IF OUR PEICE IS A KING, CHECK THE BACKSIDE
				if (CMCheckersBoard[xLoc][yLoc] == 3) {
					if (yLoc - 1 >= 0) {
						if (checkerBelongsToPlayer(CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc + 1, numRowsInBoard)]) == 0
							&& CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc + 2, numRowsInBoard)] == 0) {
							return true;
						}
						else if (checkerBelongsToPlayer(CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc - 1, numRowsInBoard)]) == 0
							&& CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc - 2, numRowsInBoard)] == 0) {
							return true;
						}
					}
				}

			}

			// That check didn't work, maybe they're a king and have an option of moving?
		}
		else { // RED PLAYER
			
			if (yLoc - 1 >= 0) {
				// DIAG. RIGHT
				if (checkerBelongsToPlayer(CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc + 1, numRowsInBoard)]) == 1
					&& CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc + 2, numRowsInBoard)] == 0) {
					return true;
				} else if (checkerBelongsToPlayer(CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc - 1, numRowsInBoard)]) == 1
					&& CMCheckersBoard[yLoc - 1][getWrappedCoordinate(xLoc - 2, numRowsInBoard)] == 0) {
					return true;
				}
			} else {
				// IF OUR PEICE IS A KING, CHECK THE BACKSIDE
				if (CMCheckersBoard[xLoc][yLoc] == 6) {
					if (yLoc + 1 <= numRowsInBoard - 1) {
						if (checkerBelongsToPlayer(CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc - 1, numRowsInBoard)]) == 1
							&& CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc - 2, numRowsInBoard)] == 0) {
							return true;
						}
						else if (checkerBelongsToPlayer(CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc + 1, numRowsInBoard)]) == 1
							&& CMCheckersBoard[yLoc + 1][getWrappedCoordinate(xLoc + 2, numRowsInBoard)] == 0) {
							return true;
						}
					}
				}

			}
		}
	}

	return false;
}

// TOBEIMPLEMENTED: Ryan
bool MakeMove(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard, int player, int fromSquareNum, int toSquareNum, bool & jumped)
{
	//Notes
	//Convert square number to array location
	//Define variables for dX and dY
	//Check if piece moves diagonally 1 or 2 spaces (dX and dY = 1 or 2)
	//If move distance more than 2 diagonal
	//		error message and return false
	//If move disance 2 diagonal but no enemy piece in between
	//		error message and return false
	//If soldier or mule moves the wrong way
	//		error message and return false
	//Print only one error message for a single move
	//Make the move, taking out any enemies in between, change values in board array
	//If piece at end of board, change to king
	//If mule != king, return true
	//If mule = king
	//		your mule = king, you lose
	//		enemy mule = king, you win
	//Print victory or defeat message
	//Terminate game using user input

	int xLocPrev = 0;
	int xLocPost = 0;
	int yLocPrev = 0;
	int yLocPost = 0;
	int xDistance = 0;
	int yDistance = 0;

	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j < numRowsInBoard; j++)
		{
			if (CMCheckersBoard[i][j] = fromSquareNum)
			{
				yLocPrev = i;
				xLocPrev = j;
				break;
			}
		}
	}

	for (int i = 0; i < numRowsInBoard; i++)
	{
		for (int j = 0; j < numRowsInBoard; j++)
		{
			if (CMCheckersBoard[i][j] = toSquareNum)
			{
				yLocPost = i;
				xLocPost = j;
				break;
			}
		}
	}

	xDistance = abs(xLocPost - xLocPrev);
	yDistance = abs(yLocPost - yLocPrev);

	if (xDistance == 1 && yDistance == 1)
	{
		//may need return here
	}
	else if (xDistance > 2 || yDistance > 2)
	{
		cerr << "Error; illegal move";
	}
	else if (xDistance == 2 && yDistance == 2)
	{
		if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'WS')
		{
			if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'WM')
			{
				if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'WK')
				{

				}
			}
		}
		if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'RS')
		{
			if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'RM')
			{
				if (CMCheckersBoard[yLocPost + 1][xLocPost + 1] != 'RK')
				{

				}
			}
		}
	}
	return false;
}

// TOBEIMPLEMENTED: Max
bool CheckWin(int CMCheckersBoard[MAX_ARRAY_SIZE][MAX_ARRAY_SIZE], int numRowsInBoard)
{
	return false;
}

// Checks if the value provided is even, if so returns true, else returns false.
bool isEven(int value) {
	if (value % 2 == 0) {
		return true;
	}
	else {
		return false;
	}
}

// Checks which player a checker belongs to, if it's blank, returns -1.
int checkerBelongsToPlayer(int checkerValue) {

	if (checkerValue >= 1 && checkerValue <= 3) {
		// WHITE PLAYER
		return 1;
	}
	else if (checkerValue >= 4 && checkerValue <= 6) {
		// RED PLAYER
		return 0;
	}
	else {
		return -1;
	}
}

// Our board is really a cylinder. This is because we can "go off the board"
//	Then come back on the other side. We need to make sure that we get the correct
//	coordinates every time we jump "off the board".
//  NOTE: This does not check whether a jump is valid or not, just manipulates the X
//       to wrap around the board.		 
int getWrappedCoordinate(int locX, int numRowsInBoard) {
	
	if (locX >(numRowsInBoard - 1)) {
		return locX % numRowsInBoard;
	}
	else if (locX < 0) {
		return numRowsInBoard % locX;
	}
	else {
		return locX;
	}
}